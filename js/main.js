/**
 * Character Pixel Generator - Main App Entry Point
 * 
 * This is the main application controller that initializes all components
 * and manages the overall character generation workflow.
 */
import { MonsterGenerator } from './generators/monster/monster-generator.js';
import { HumanGenerator } from './generators/human/human-generator.js';
import { MonsterBackstoryGenerator } from './generators/monster/monster-backstory.js';
import { HumanBackstoryGenerator } from './generators/human/human-backstory.js';
import { CharacterRenderer } from './core/renderer.js';

// App modules
import { UIManager } from './app/UIManager.js';
import { ModalManager } from './app/ModalManager.js';
import { ExportManager } from './app/ExportManager.js';
import { CharacterManager } from './app/CharacterManager.js';

class App {
    constructor() {
        // Core properties
        this.canvasSize = 50;
        this.characters = [];
        this.batchOptions = { preset: 'standard' };

        // Initialize generators
        this.monsterGenerator = new MonsterGenerator(this.canvasSize);
        this.humanGenerator = new HumanGenerator(this.canvasSize);
        this.monsterBackstoryGenerator = new MonsterBackstoryGenerator();
        this.humanBackstoryGenerator = new HumanBackstoryGenerator();

        // Initialize renderer
        this.characterRenderer = new CharacterRenderer(3, this.canvasSize);

        // Initialize managers
        this.characterManager = new CharacterManager();
        this.uiManager = new UIManager(this);
        this.modalManager = new ModalManager(this);
        this.exportManager = new ExportManager(this);

        // State
        this.currentParams = null;
        this.displayOptions = null;

        // Expose for debugging
        window.characterManager = this.characterManager;

        this.init();
        this.setupModalEdit();
    }

    init() {
        // Initialize display options FIRST (before UI setup triggers regeneration)
        this.displayOptions = {
            showStickFigure: document.getElementById('showStickFigure').checked,
            showThickness: document.getElementById('showThickness').checked,
            showHeatmap: document.getElementById('showHeatmap').checked,
            showFinal: document.getElementById('showFinal').checked,
            showGrid: document.getElementById('showGrid').checked
        };

        // Setup UI (this may trigger regeneration via preset application)
        this.uiManager.setup();
        this.modalManager.setup();

        // Update params from UI (sliders are now initialized)
        this.currentParams = this.uiManager.getParamsFromUI();

        // Generate initial character if not already generated by setup
        if (this.characters.length === 0) {
            this.generateCharacters(1);
        }
    }

    // --- Getters for current generator based on UI selection ---

    get currentGenerator() {
        const type = document.getElementById('generatorType').value;
        return type === 'human' ? this.humanGenerator : this.monsterGenerator;
    }

    get currentBackstoryGenerator() {
        const type = document.getElementById('generatorType').value;
        return type === 'human' ? this.humanBackstoryGenerator : this.monsterBackstoryGenerator;
    }

    // --- Canvas Size Management ---

    updateCanvasSize(newSize) {
        this.canvasSize = newSize;
        this.monsterGenerator = new MonsterGenerator(this.canvasSize);
        this.humanGenerator = new HumanGenerator(this.canvasSize);
        this.characterRenderer = new CharacterRenderer(3, this.canvasSize);
        this.regenerateCurrentCharacters();
    }

    // --- Character Generation ---

    generateCharacters(count) {
        this.characters = [];
        this.currentBackstoryGenerator.resetPools();

        for (let i = 0; i < count; i++) {
            const params = this.currentGenerator.randomParamsInRange(this.batchOptions.preset);

            // Merge with UI params
            const mergedParams = {
                ...params,
                enableSmoothing: this.currentParams.enableSmoothing,
                enableLighting: this.currentParams.enableLighting,
                lightDirection: this.currentParams.lightDirection,
                showOutline: this.currentParams.showOutline,
                outlineColor: this.currentParams.outlineColor
            };

            const character = this.currentGenerator.generate(mergedParams);
            // Generate animation frames for the modal animation
            character.animationFrames = this.currentGenerator.generateAnimationFrames(mergedParams);
            character.backstory = this.currentBackstoryGenerator.generate(character.name);
            this.characters.push(character);
        }

        this.renderCharacters();
    }

    regenerateCurrentCharacters() {
        if (this.characters.length === 0) {
            this.generateCharacters(1);
            return;
        }

        const count = this.characters.length;
        // Store old characters to preserve identity (seed, name, backstory, palette)
        const oldCharacters = [...this.characters];

        this.characters = [];
        this.currentBackstoryGenerator.resetPools();

        for (let i = 0; i < count; i++) {
            const oldChar = oldCharacters[i];
            const seed = oldChar.params.seed || Math.floor(Math.random() * 2147483647);

            // Resolve parameters using the current UI ranges but with the character's original seed.
            // This ensures that:
            // 1. Changing a slider (range) updates the character's proportions naturally.
            // 2. The character's "identity" (relative proportions) remains consistent.
            const params = this.currentGenerator.resolveParams(this.currentParams, seed);

            // Restore colors/palette from original character to ensure visual identity is preserved
            params.palette = oldChar.params.palette;
            if (oldChar.params.humanColors) {
                params.humanColors = oldChar.params.humanColors;
            }

            const mergedParams = {
                ...params,
                enableSmoothing: this.currentParams.enableSmoothing,
                enableLighting: this.currentParams.enableLighting,
                lightDirection: this.currentParams.lightDirection,
                showOutline: this.currentParams.showOutline,
                outlineColor: this.currentParams.outlineColor
            };

            const character = this.currentGenerator.generate(mergedParams);

            // Restore name and backstory
            character.name = oldChar.name;
            character.backstory = oldChar.backstory;

            // Generate animation frames for the modal animation
            character.animationFrames = this.currentGenerator.generateAnimationFrames(mergedParams);

            this.characters.push(character);
        }

        this.renderCharacters();
    }

    reprocessCurrentCharacters() {
        if (this.characters.length === 0) return;

        this.characters = this.characters.map(char => {
            const newParams = {
                ...char.params,
                enableSmoothing: this.currentParams.enableSmoothing,
                enableLighting: this.currentParams.enableLighting,
                lightDirection: this.currentParams.lightDirection,
                showOutline: this.currentParams.showOutline,
                outlineColor: this.currentParams.outlineColor
            };

            const reprocessed = this.currentGenerator.reprocess(char, newParams);

            // Regenerate animation frames with new effects
            reprocessed.animationFrames = this.currentGenerator.generateAnimationFrames(newParams);

            reprocessed.name = char.name;
            reprocessed.backstory = char.backstory;
            return reprocessed;
        });

        this.renderCharacters();
    }

    // --- Rendering ---

    redrawCharacters() {
        this.renderCharacters();
    }

    renderCharacters() {
        const grid = document.getElementById('canvasGrid');
        grid.innerHTML = '';
        this.canvasGrid.innerHTML = '';
        this.canvasGrid.className = 'grid-container'; // Reset class for grid view

        this.characters.forEach((character) => {
            const card = document.createElement('div');
            card.className = 'char-card';
            card.style.cursor = 'pointer';
            card.title = 'Click to view details';
            card.addEventListener('click', () => this.modalManager.show(character));

            const canvas = this.characterRenderer.createCanvas();
            this.characterRenderer.drawCharacter(canvas, character, this.displayOptions);
            card.appendChild(canvas);

            // Add name label if in array
            if (character.name) {
                const label = document.createElement('div');
                label.className = 'char-name';
                label.textContent = character.name;
                card.appendChild(label);
            }

            this.canvasGrid.appendChild(card);
        });
    }

    setupModalEdit() {
        // Setup the "EDIT" button in the modal
        const editBtn = document.getElementById('editCharBtn');
        if (editBtn) {
            editBtn.addEventListener('click', () => {
                const character = this.modalManager.currentCharacter;
                if (!character) return;

                // Close modal
                this.modalManager.hide();

                // Switch to edit mode
                this.characterManager.selectCharacter(character);
                this.uiManager.switchMode('single');
                this.uiManager.populateSingleModeControls(character);

                // Ensure the view updates to show only this character
                this.renderSingleCharacterView(character);
            });
            card.appendChild(canvas);
            card.appendChild(nameDiv);
            card.appendChild(storyDiv);
            grid.appendChild(card);
        });
    }
}

// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.app = new App();
});
